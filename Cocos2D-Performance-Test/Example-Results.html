<body>

<br/>
<p>Blog post about these results coming soon on the <a href="http://www.learn-cocos2d.com/2011/11/depth-ios-cocos2d-performance-analysis-test-project">Learn Cocos2D blog</a>.
</p>
<p>All Cocos2D tests were made with Cocos2D v1.0.1 stable release. The various texture atlas images were created with <a href="http://www.texturepacker.com">TexturePacker</a>, the Tilemaps were created with <a href="http://www.mapeditor.org">Tiled Map Editor</a>.
</p>
<p>
The performance measuring code is based on <a href="http://mikeash.com/pyblog/performance-comparisons-of-common-operations-iphone-edition.html">Mike Ash's performance test code</a> as well as the iPhone version ported by an <a href="http://aussiebloke.blogspot.com/2010/01/micro-benchmarking-2nd-3rd-gen-iphones.html">"aussie bloke" (Stuart Carnie)</a>.
</p>
<br/>

<table border="1">
<tr>
<td width="33%">
iPad 1 (iOS 5.0.1)
</td>
<td width="33%">
iPod 4th Generation (iOS 5.0.1)
</td>
<td width="33%">
iPhone 3G (iOS 4.2.1)
</td>
</tr>
<tr>

<td>



A nanosecond (ns) is one billionth of a second (0.000 000 001 second). 					  One nanosecond is to one second as one second is to 31.7 years. 					  One Gigahertz (GHz) equals 1,000,000,000 Hz. One cycle of a 1 GHz CPU takes 1 nanosecond. <h4>Array Tests</h4>Testing Cocos2D's CCArray performance against regular NSMutableArray.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>NSMutableArray objectAtIndex:</td><td align="right">77</td></tr><tr><td>CCArray objectAtIndex:</td><td align="right">82</td></tr><tr><td>CFArray GetValueAtIndex</td><td align="right">136</td></tr><tr><td>CCArray exchangeObjectAtIndex</td><td align="right">254</td></tr><tr><td>CCArray withCapacity addObject:</td><td align="right">325</td></tr><tr><td>CCArray addObject:</td><td align="right">373</td></tr><tr><td>NSMutableArray insertObject: atIndex:0</td><td align="right">478</td></tr><tr><td>NSMutableArray withCapacity addObject:</td><td align="right">604</td></tr><tr><td>NSMutableArray addObject:</td><td align="right">622</td></tr><tr><td>CCArray removeLastObject</td><td align="right">664</td></tr><tr><td>NSMutableArray removeLastObject</td><td align="right">1.039</td></tr><tr><td>CCArray removeObjectAtIndex</td><td align="right">1.569</td></tr><tr><td>NSMutableArray removeObjectAtIndex</td><td align="right">1.784</td></tr><tr><td>NSMutableArray exchangeObjectAtIndex</td><td align="right">1.985</td></tr><tr><td>CCArray indexOfObject</td><td align="right">15.309</td></tr><tr><td>CCArray containsObject</td><td align="right">15.506</td></tr><tr><td>CCArray fast enumeration</td><td align="right">22.050</td></tr><tr><td>NSMutableArray fast enumeration</td><td align="right">28.418</td></tr><tr><td>NSMutableArray indexOfObject</td><td align="right">38.334</td></tr><tr><td>NSMutableArray containsObject</td><td align="right">40.514</td></tr><tr><td>CCArray insertObject: atIndex:0</td><td align="right">56.976</td></tr><tr><td>NSMutableArray enumeration</td><td align="right">84.579</td></tr><tr><td>CCArray enumeration</td><td align="right">88.456</td></tr><tr><td>NSMutableArray makeObjectsPerformSelector withObject</td><td align="right">121.212</td></tr><tr><td>CCArray makeObjectsPerformSelector withObject</td><td align="right">128.970</td></tr><tr><td>NSMutableArray makeObjectsPerformSelector</td><td align="right">183.931</td></tr><tr><td>CCArray makeObjectsPerformSelector</td><td align="right">234.260</td></tr><tr><td>NSMutableArray add/removeObjectsInArray</td><td align="right">883.085</td></tr><tr><td>CCArray add/removeObjectsInArray</td><td align="right">2.398.743</td></tr></table></p>
 <h4>Object Creation</h4>These tests tell you how long it takes to allocate memory, 			 initialize the object, and deallocate it. The longer this takes for an object, the higher the chance that 			 doing this during gameplay will negatively affect performance. Note that <strong>these tests do not give any indication 			 whatsoever of the runtime/rendering performance</strong> of these objects.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>NSAutoreleasePool alloc/init/release</td><td align="right">630</td></tr><tr><td>NSObject alloc/init/release</td><td align="right">3.137</td></tr><tr><td>CCNode alloc/init/release</td><td align="right">3.928</td></tr><tr><td>CCMoveTo alloc/init/release</td><td align="right">4.259</td></tr><tr><td>CCSequence alloc/initOne/release</td><td align="right">5.096</td></tr><tr><td>CCSprite alloc/initWithFile/release</td><td align="right">23.554</td></tr><tr><td>CCParticleSystemQuad 25 particles alloc/init/release</td><td align="right">168.798</td></tr><tr><td>CCParticleSystemQuad 250 particles alloc/init/release</td><td align="right">413.338</td></tr><tr><td>CCLabelTTF alloc/initWithString/release</td><td align="right">579.575</td></tr><tr><td>CCLabelBMFont alloc/initWithString/release</td><td align="right">653.608</td></tr><tr><td>CCTMXTiledMap small alloc/init/release</td><td align="right">15.724.142</td></tr><tr><td>CCTMXTiledMap large alloc/init/release</td><td align="right">1.129.904.604</td></tr></table></p>
 <h4>Loading Textures</h4>Time it takes to load and unload the same 1024x1024 texture using a variety of different image file formats, compression and color bit depths.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>PVRTC4.pvr.ccz</td><td align="right">651.275</td></tr><tr><td>PVRTC2.pvr.ccz</td><td align="right">748.332</td></tr><tr><td>PVRTC2.pvr</td><td align="right">5.574.554</td></tr><tr><td>PVRTC4.pvr</td><td align="right">8.747.835</td></tr><tr><td>PVRTC2.pvr.gz</td><td align="right">12.382.721</td></tr><tr><td>PVRTC4.pvr.gz</td><td align="right">21.729.260</td></tr><tr><td>RGB565.pvr</td><td align="right">28.060.432</td></tr><tr><td>RGBA5551.pvr</td><td align="right">28.422.838</td></tr><tr><td>RGBA4444.pvr</td><td align="right">28.423.882</td></tr><tr><td>RGBA4444.pvr.ccz</td><td align="right">39.611.505</td></tr><tr><td>RGBA5551.pvr.ccz</td><td align="right">41.135.829</td></tr><tr><td>RGB565.pvr.ccz</td><td align="right">41.304.006</td></tr><tr><td>RGBA4444.pvr.gz</td><td align="right">46.920.818</td></tr><tr><td>RGBA5551.pvr.gz</td><td align="right">47.976.535</td></tr><tr><td>RGB565.pvr.gz</td><td align="right">49.175.556</td></tr><tr><td>RGBA8888.pvr</td><td align="right">54.818.895</td></tr><tr><td>RGBA8888.pvr.ccz</td><td align="right">81.683.766</td></tr><tr><td>RGBA8888.pvr.gz</td><td align="right">95.916.186</td></tr><tr><td>RGB565.png</td><td align="right">113.274.316</td></tr><tr><td>RGBA5551.png</td><td align="right">114.599.338</td></tr><tr><td>RGBA4444.png</td><td align="right">115.231.899</td></tr><tr><td>RGBA8888.png</td><td align="right">127.134.580</td></tr><tr><td>RGBA8888.jpg</td><td align="right">851.384.812</td></tr><tr><td>RGBA5551.jpg</td><td align="right">865.443.154</td></tr><tr><td>RGBA4444.jpg</td><td align="right">867.075.779</td></tr><tr><td>RGB565.jpg</td><td align="right">870.333.871</td></tr></table></p>
 <h4>Node Hierarchy (children)</h4>The performance of functions that act on the node hierarchy (children list) depends heavily on the number of children.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>getChildByTag w/ 10 Nodes</td><td align="right">642</td></tr><tr><td>reorderChild w/ 10 Nodes</td><td align="right">3.728</td></tr><tr><td>getChildByTag w/ 100 Nodes</td><td align="right">3.960</td></tr><tr><td>reorderChild w/ 100 Nodes</td><td align="right">9.322</td></tr><tr><td>addChild with tag</td><td align="right">9.903</td></tr><tr><td>getChildByTag w/ 500 Nodes</td><td align="right">20.861</td></tr><tr><td>removeChildByTag</td><td align="right">22.331</td></tr><tr><td>reorderChild w/ 500 Nodes</td><td align="right">33.852</td></tr><tr><td>getChildByTag w/ 2,500 Nodes</td><td align="right">123.275</td></tr><tr><td>reorderChild w/ 2,500 Nodes</td><td align="right">179.381</td></tr></table></p>
 <h4>Messaging / Function Calls</h4>Low-level overhead for calling C++ functions respectively sending Objective-C messages in various ways.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>C++ virtual method call</td><td align="right">13</td></tr><tr><td>IMP-cached message send</td><td align="right">17</td></tr><tr><td>C++ cached virtual method call</td><td align="right">30</td></tr><tr><td>Objective-C message send</td><td align="right">37</td></tr><tr><td>NSInvocation message send</td><td align="right">439</td></tr></table></p>
 <h4>Arithmetic Tests</h4>Simple calculations done frequently in an app, using various data types.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Integer multiplication</td><td align="right">10</td></tr><tr><td>Float multiplication</td><td align="right">36</td></tr><tr><td>Double multiplication</td><td align="right">47</td></tr><tr><td>Integer division</td><td align="right">48</td></tr><tr><td>Float division with int conversion</td><td align="right">72</td></tr><tr><td>Float division</td><td align="right">73</td></tr><tr><td>Float square root</td><td align="right">106</td></tr><tr><td>Double division</td><td align="right">108</td></tr><tr><td>Double division with int conversion</td><td align="right">111</td></tr><tr><td>Double square root</td><td align="right">148</td></tr><tr><td>Accelerometer Highpass filter</td><td align="right">267</td></tr></table></p>
 <h4>Memory Tests</h4>Allocating and releasing memory.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>16 byte memcpy</td><td align="right">26</td></tr><tr><td>16 byte malloc/free</td><td align="right">503</td></tr><tr><td>16MB malloc/free</td><td align="right">14.629</td></tr><tr><td>1MB memcpy</td><td align="right">1.087.525</td></tr></table></p>
 <h4>File IO</h4><p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Read 16MB file</td><td align="right">121.258</td></tr><tr><td>Read 16-byte file</td><td align="right">124.130</td></tr><tr><td>Write 16-byte file</td><td align="right">499.013</td></tr><tr><td>Write 16-byte file (atomic)</td><td align="right">819.701</td></tr><tr><td>Write 16MB file</td><td align="right">880.762</td></tr><tr><td>Write 16MB file (atomic)</td><td align="right">1.134.361</td></tr></table></p>
 <h4>Miscellaneous Tests</h4><p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Zero-second delayed perform</td><td align="right">294</td></tr><tr><td>pthread create/join</td><td align="right">142.973</td></tr></table></p>

</td>

<td>

A nanosecond (ns) is one billionth of a second (0.000 000 001 second). 					  One nanosecond is to one second as one second is to 31.7 years. 					  One Gigahertz (GHz) equals 1,000,000,000 Hz. One cycle of a 1 GHz CPU takes 1 nanosecond. <h4>Array Tests</h4>Testing Cocos2D's CCArray performance against regular NSMutableArray.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>NSMutableArray objectAtIndex:</td><td align="right">100</td></tr><tr><td>CCArray objectAtIndex:</td><td align="right">105</td></tr><tr><td>CFArray GetValueAtIndex</td><td align="right">176</td></tr><tr><td>CCArray exchangeObjectAtIndex</td><td align="right">324</td></tr><tr><td>CCArray withCapacity addObject:</td><td align="right">416</td></tr><tr><td>CCArray addObject:</td><td align="right">419</td></tr><tr><td>NSMutableArray insertObject: atIndex:0</td><td align="right">572</td></tr><tr><td>NSMutableArray withCapacity addObject:</td><td align="right">687</td></tr><tr><td>NSMutableArray addObject:</td><td align="right">688</td></tr><tr><td>CCArray removeLastObject</td><td align="right">857</td></tr><tr><td>NSMutableArray removeLastObject</td><td align="right">1.336</td></tr><tr><td>CCArray removeObjectAtIndex</td><td align="right">2.040</td></tr><tr><td>NSMutableArray removeObjectAtIndex</td><td align="right">2.328</td></tr><tr><td>NSMutableArray exchangeObjectAtIndex</td><td align="right">2.592</td></tr><tr><td>CCArray containsObject</td><td align="right">19.886</td></tr><tr><td>CCArray indexOfObject</td><td align="right">19.962</td></tr><tr><td>CCArray fast enumeration</td><td align="right">28.560</td></tr><tr><td>NSMutableArray fast enumeration</td><td align="right">36.668</td></tr><tr><td>NSMutableArray indexOfObject</td><td align="right">49.743</td></tr><tr><td>NSMutableArray containsObject</td><td align="right">52.521</td></tr><tr><td>CCArray insertObject: atIndex:0</td><td align="right">72.364</td></tr><tr><td>NSMutableArray enumeration</td><td align="right">109.026</td></tr><tr><td>CCArray enumeration</td><td align="right">114.515</td></tr><tr><td>NSMutableArray makeObjectsPerformSelector withObject</td><td align="right">153.813</td></tr><tr><td>CCArray makeObjectsPerformSelector withObject</td><td align="right">167.441</td></tr><tr><td>NSMutableArray makeObjectsPerformSelector</td><td align="right">238.568</td></tr><tr><td>CCArray makeObjectsPerformSelector</td><td align="right">250.246</td></tr><tr><td>NSMutableArray add/removeObjectsInArray</td><td align="right">953.803</td></tr><tr><td>CCArray add/removeObjectsInArray</td><td align="right">3.090.132</td></tr></table></p>
 <h4>Object Creation</h4>These tests tell you how long it takes to allocate memory, 			 initialize the object, and deallocate it. The longer this takes for an object, the higher the chance that 			 doing this during gameplay will negatively affect performance. Note that <strong>these tests do not give any indication 			 whatsoever of the runtime/rendering performance</strong> of these objects.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>NSAutoreleasePool alloc/init/release</td><td align="right">892</td></tr><tr><td>NSObject alloc/init/release</td><td align="right">4.050</td></tr><tr><td>CCNode alloc/init/release</td><td align="right">5.099</td></tr><tr><td>CCMoveTo alloc/init/release</td><td align="right">5.504</td></tr><tr><td>CCSequence alloc/initOne/release</td><td align="right">6.680</td></tr><tr><td>CCSprite alloc/initWithFile/release</td><td align="right">29.451</td></tr><tr><td>CCParticleSystemQuad 25 particles alloc/init/release</td><td align="right">154.623</td></tr><tr><td>CCParticleSystemQuad 250 particles alloc/init/release</td><td align="right">508.432</td></tr><tr><td>CCLabelTTF alloc/initWithString/release</td><td align="right">739.952</td></tr><tr><td>CCLabelBMFont alloc/initWithString/release</td><td align="right">847.045</td></tr><tr><td>CCTMXTiledMap small alloc/init/release</td><td align="right">18.578.580</td></tr><tr><td>CCTMXTiledMap large alloc/init/release</td><td align="right">1.438.647.079</td></tr></table></p>
 <h4>Loading Textures</h4>Time it takes to load and unload the same 1024x1024 texture using a variety of different image file formats, compression and color bit depths.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>PVRTC4.pvr.ccz</td><td align="right">904.563</td></tr><tr><td>PVRTC2.pvr.ccz</td><td align="right">917.834</td></tr><tr><td>PVRTC2.pvr</td><td align="right">6.600.616</td></tr><tr><td>PVRTC4.pvr</td><td align="right">10.321.815</td></tr><tr><td>PVRTC2.pvr.gz</td><td align="right">15.267.200</td></tr><tr><td>PVRTC4.pvr.gz</td><td align="right">27.684.074</td></tr><tr><td>RGB565.pvr</td><td align="right">32.698.952</td></tr><tr><td>RGBA4444.pvr</td><td align="right">32.708.815</td></tr><tr><td>RGBA5551.pvr</td><td align="right">32.889.440</td></tr><tr><td>RGBA4444.pvr.ccz</td><td align="right">47.412.733</td></tr><tr><td>RGBA5551.pvr.ccz</td><td align="right">48.655.328</td></tr><tr><td>RGB565.pvr.ccz</td><td align="right">49.367.906</td></tr><tr><td>RGBA4444.pvr.gz</td><td align="right">58.213.932</td></tr><tr><td>RGBA5551.pvr.gz</td><td align="right">59.741.089</td></tr><tr><td>RGB565.pvr.gz</td><td align="right">60.072.209</td></tr><tr><td>RGBA8888.pvr</td><td align="right">63.956.478</td></tr><tr><td>RGBA8888.pvr.ccz</td><td align="right">97.924.909</td></tr><tr><td>RGBA8888.pvr.gz</td><td align="right">117.333.748</td></tr><tr><td>RGB565.png</td><td align="right">135.442.519</td></tr><tr><td>RGBA5551.png</td><td align="right">137.939.474</td></tr><tr><td>RGBA4444.png</td><td align="right">138.107.768</td></tr><tr><td>RGBA8888.png</td><td align="right">149.741.913</td></tr><tr><td>RGBA8888.jpg</td><td align="right">1.088.439.833</td></tr><tr><td>RGBA5551.jpg</td><td align="right">1.099.894.992</td></tr><tr><td>RGBA4444.jpg</td><td align="right">1.101.358.371</td></tr><tr><td>RGB565.jpg</td><td align="right">1.102.385.583</td></tr></table></p>
 <h4>Node Hierarchy (children)</h4>The performance of functions that act on the node hierarchy (children list) depends heavily on the number of children.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>getChildByTag w/ 10 Nodes</td><td align="right">846</td></tr><tr><td>reorderChild w/ 10 Nodes</td><td align="right">4.799</td></tr><tr><td>getChildByTag w/ 100 Nodes</td><td align="right">5.163</td></tr><tr><td>reorderChild w/ 100 Nodes</td><td align="right">11.768</td></tr><tr><td>addChild with tag</td><td align="right">12.631</td></tr><tr><td>getChildByTag w/ 500 Nodes</td><td align="right">27.561</td></tr><tr><td>removeChildByTag</td><td align="right">29.432</td></tr><tr><td>reorderChild w/ 500 Nodes</td><td align="right">44.279</td></tr><tr><td>getChildByTag w/ 2,500 Nodes</td><td align="right">156.393</td></tr><tr><td>reorderChild w/ 2,500 Nodes</td><td align="right">227.192</td></tr></table></p>
 <h4>Messaging / Function Calls</h4>Low-level overhead for calling C++ functions respectively sending Objective-C messages in various ways.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>C++ virtual method call</td><td align="right">16</td></tr><tr><td>IMP-cached message send</td><td align="right">22</td></tr><tr><td>C++ cached virtual method call</td><td align="right">39</td></tr><tr><td>Objective-C message send</td><td align="right">48</td></tr><tr><td>NSInvocation message send</td><td align="right">569</td></tr></table></p>
 <h4>Arithmetic Tests</h4>Simple calculations done frequently in an app, using various data types.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Integer multiplication</td><td align="right">12</td></tr><tr><td>Float multiplication</td><td align="right">47</td></tr><tr><td>Double multiplication</td><td align="right">61</td></tr><tr><td>Integer division</td><td align="right">63</td></tr><tr><td>Float division</td><td align="right">93</td></tr><tr><td>Float division with int conversion</td><td align="right">94</td></tr><tr><td>Float square root</td><td align="right">137</td></tr><tr><td>Double division</td><td align="right">140</td></tr><tr><td>Double division with int conversion</td><td align="right">145</td></tr><tr><td>Double square root</td><td align="right">190</td></tr><tr><td>Accelerometer Highpass filter</td><td align="right">346</td></tr></table></p>
 <h4>Memory Tests</h4>Allocating and releasing memory.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>16 byte memcpy</td><td align="right">34</td></tr><tr><td>16 byte malloc/free</td><td align="right">649</td></tr><tr><td>16MB malloc/free</td><td align="right">21.227</td></tr><tr><td>1MB memcpy</td><td align="right">1.178.374</td></tr></table></p>
 <h4>File IO</h4><p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Read 16-byte file</td><td align="right">149.936</td></tr><tr><td>Read 16MB file</td><td align="right">156.952</td></tr><tr><td>Write 16-byte file</td><td align="right">660.388</td></tr><tr><td>Write 16-byte file (atomic)</td><td align="right">943.402</td></tr><tr><td>Write 16MB file (atomic)</td><td align="right">1.043.194</td></tr><tr><td>Write 16MB file</td><td align="right">1.044.325</td></tr></table></p>
 <h4>Miscellaneous Tests</h4><p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Zero-second delayed perform</td><td align="right">5</td></tr><tr><td>pthread create/join</td><td align="right">180.477</td></tr></table></p>


</td>
<td>

A nanosecond (ns) is one billionth of a second (0.000 000 001 second). 					  One nanosecond is to one second as one second is to 31.7 years. 					  One Gigahertz (GHz) equals 1,000,000,000 Hz. One cycle of a 1 GHz CPU takes 1 nanosecond. <h4>Array Tests</h4>Testing Cocos2D's CCArray performance against regular NSMutableArray.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>CCArray objectAtIndex:</td><td align="right">380</td></tr><tr><td>NSMutableArray objectAtIndex:</td><td align="right">460</td></tr><tr><td>CCArray exchangeObjectAtIndex</td><td align="right">1.136</td></tr><tr><td>CFArray GetValueAtIndex</td><td align="right">1.514</td></tr><tr><td>CCArray addObject:</td><td align="right">3.532</td></tr><tr><td>CCArray withCapacity addObject:</td><td align="right">3.562</td></tr><tr><td>NSMutableArray insertObject: atIndex:0</td><td align="right">5.567</td></tr><tr><td>NSMutableArray withCapacity addObject:</td><td align="right">6.017</td></tr><tr><td>NSMutableArray addObject:</td><td align="right">6.173</td></tr><tr><td>CCArray removeLastObject</td><td align="right">9.820</td></tr><tr><td>NSMutableArray removeLastObject</td><td align="right">10.938</td></tr><tr><td>CCArray removeObjectAtIndex</td><td align="right">27.121</td></tr><tr><td>NSMutableArray removeObjectAtIndex</td><td align="right">32.427</td></tr><tr><td>NSMutableArray exchangeObjectAtIndex</td><td align="right">41.978</td></tr><tr><td>CCArray containsObject</td><td align="right">58.970</td></tr><tr><td>CCArray indexOfObject</td><td align="right">63.629</td></tr><tr><td>CCArray fast enumeration</td><td align="right">84.829</td></tr><tr><td>NSMutableArray fast enumeration</td><td align="right">110.895</td></tr><tr><td>NSMutableArray containsObject</td><td align="right">159.196</td></tr><tr><td>NSMutableArray indexOfObject</td><td align="right">160.993</td></tr><tr><td>CCArray insertObject: atIndex:0</td><td align="right">360.513</td></tr><tr><td>NSMutableArray enumeration</td><td align="right">463.399</td></tr><tr><td>NSMutableArray makeObjectsPerformSelector</td><td align="right">508.814</td></tr><tr><td>NSMutableArray makeObjectsPerformSelector withObject</td><td align="right">541.626</td></tr><tr><td>CCArray makeObjectsPerformSelector</td><td align="right">681.136</td></tr><tr><td>CCArray makeObjectsPerformSelector withObject</td><td align="right">703.787</td></tr><tr><td>CCArray enumeration</td><td align="right">724.694</td></tr><tr><td>NSMutableArray add/removeObjectsInArray</td><td align="right">6.701.924</td></tr><tr><td>CCArray add/removeObjectsInArray</td><td align="right">9.801.766</td></tr></table></p>
 <h4>Object Creation</h4>These tests tell you how long it takes to allocate memory, 			 initialize the object, and deallocate it. The longer this takes for an object, the higher the chance that 			 doing this during gameplay will negatively affect performance. Note that <strong>these tests do not give any indication 			 whatsoever of the runtime/rendering performance</strong> of these objects.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>NSAutoreleasePool alloc/init/release</td><td align="right">10.672</td></tr><tr><td>NSObject alloc/init/release</td><td align="right">19.240</td></tr><tr><td>CCNode alloc/init/release</td><td align="right">25.884</td></tr><tr><td>CCMoveTo alloc/init/release</td><td align="right">26.179</td></tr><tr><td>CCSequence alloc/initOne/release</td><td align="right">41.992</td></tr><tr><td>CCSprite alloc/initWithFile/release</td><td align="right">149.578</td></tr><tr><td>CCParticleSystemQuad 25 particles alloc/init/release</td><td align="right">400.082</td></tr><tr><td>CCParticleSystemQuad 250 particles alloc/init/release</td><td align="right">730.617</td></tr><tr><td>CCLabelTTF alloc/initWithString/release</td><td align="right">3.411.428</td></tr><tr><td>CCLabelBMFont alloc/initWithString/release</td><td align="right">3.792.740</td></tr><tr><td>CCTMXTiledMap small alloc/init/release</td><td align="right">82.298.633</td></tr><tr><td>CCTMXTiledMap large alloc/init/release</td><td align="right">6.078.265.400</td></tr></table></p>
 <h4>Loading Textures</h4>Time it takes to load and unload the same 1024x1024 texture using a variety of different image file formats, compression and color bit depths.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>PVRTC4.pvr.ccz</td><td align="right">4.932.652</td></tr><tr><td>PVRTC2.pvr.ccz</td><td align="right">5.143.908</td></tr><tr><td>PVRTC2.pvr</td><td align="right">20.710.732</td></tr><tr><td>PVRTC4.pvr</td><td align="right">33.422.953</td></tr><tr><td>PVRTC2.pvr.gz</td><td align="right">46.133.937</td></tr><tr><td>PVRTC4.pvr.gz</td><td align="right">86.878.310</td></tr><tr><td>RGB565.pvr</td><td align="right">132.076.267</td></tr><tr><td>RGBA4444.pvr</td><td align="right">155.906.383</td></tr><tr><td>RGBA5551.pvr</td><td align="right">157.559.150</td></tr><tr><td>RGB565.pvr.ccz</td><td align="right">189.076.883</td></tr><tr><td>RGBA5551.pvr.ccz</td><td align="right">206.933.150</td></tr><tr><td>RGBA4444.pvr.ccz</td><td align="right">208.405.133</td></tr><tr><td>RGB565.pvr.gz</td><td align="right">212.562.350</td></tr><tr><td>RGBA4444.pvr.gz</td><td align="right">226.271.433</td></tr><tr><td>RGBA5551.pvr.gz</td><td align="right">228.623.450</td></tr><tr><td>RGBA8888.pvr</td><td align="right">285.217.617</td></tr><tr><td>RGBA8888.pvr.ccz</td><td align="right">392.353.400</td></tr><tr><td>RGBA8888.pvr.gz</td><td align="right">420.908.317</td></tr><tr><td>RGB565.png</td><td align="right">697.689.750</td></tr><tr><td>RGBA4444.png</td><td align="right">702.992.150</td></tr><tr><td>RGBA5551.png</td><td align="right">704.371.517</td></tr><tr><td>RGBA8888.png</td><td align="right">740.525.900</td></tr><tr><td>RGBA8888.jpg</td><td align="right">4.250.968.067</td></tr><tr><td>RGBA4444.jpg</td><td align="right">4.320.874.967</td></tr><tr><td>RGBA5551.jpg</td><td align="right">4.336.442.100</td></tr><tr><td>RGB565.jpg</td><td align="right">4.377.636.567</td></tr></table></p>
 <h4>Node Hierarchy (children)</h4>The performance of functions that act on the node hierarchy (children list) depends heavily on the number of children.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>getChildByTag w/ 10 Nodes</td><td align="right">3.950</td></tr><tr><td>getChildByTag w/ 100 Nodes</td><td align="right">21.985</td></tr><tr><td>reorderChild w/ 10 Nodes</td><td align="right">22.472</td></tr><tr><td>reorderChild w/ 100 Nodes</td><td align="right">56.199</td></tr><tr><td>addChild with tag</td><td align="right">59.295</td></tr><tr><td>removeChildByTag</td><td align="right">92.136</td></tr><tr><td>getChildByTag w/ 500 Nodes</td><td align="right">157.449</td></tr><tr><td>reorderChild w/ 500 Nodes</td><td align="right">270.803</td></tr><tr><td>getChildByTag w/ 2,500 Nodes</td><td align="right">357.068</td></tr><tr><td>reorderChild w/ 2,500 Nodes</td><td align="right">1.422.534</td></tr></table></p>
 <h4>Messaging / Function Calls</h4>Low-level overhead for calling C++ functions respectively sending Objective-C messages in various ways.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>C++ virtual method call</td><td align="right">62</td></tr><tr><td>IMP-cached message send</td><td align="right">69</td></tr><tr><td>C++ cached virtual method call</td><td align="right">134</td></tr><tr><td>Objective-C message send</td><td align="right">166</td></tr><tr><td>NSInvocation message send</td><td align="right">2.000</td></tr></table></p>
 <h4>Arithmetic Tests</h4>Simple calculations done frequently in an app, using various data types.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Integer multiplication</td><td align="right">19</td></tr><tr><td>Float multiplication</td><td align="right">41</td></tr><tr><td>Double multiplication</td><td align="right">45</td></tr><tr><td>Float division</td><td align="right">75</td></tr><tr><td>Float division with int conversion</td><td align="right">105</td></tr><tr><td>Double division</td><td align="right">115</td></tr><tr><td>Float square root</td><td align="right">144</td></tr><tr><td>Double division with int conversion</td><td align="right">147</td></tr><tr><td>Double square root</td><td align="right">186</td></tr><tr><td>Integer division</td><td align="right">367</td></tr><tr><td>Accelerometer Highpass filter</td><td align="right">422</td></tr></table></p>
 <h4>Memory Tests</h4>Allocating and releasing memory.<p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>16 byte memcpy</td><td align="right">153</td></tr><tr><td>16 byte malloc/free</td><td align="right">2.747</td></tr><tr><td>16MB malloc/free</td><td align="right">36.955</td></tr><tr><td>1MB memcpy</td><td align="right">10.162.236</td></tr></table></p>
 <h4>File IO</h4><p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Read 16MB file</td><td align="right">856.130</td></tr><tr><td>Read 16-byte file</td><td align="right">858.290</td></tr><tr><td>Write 16MB file (atomic)</td><td align="right">2.214.739</td></tr><tr><td>Write 16-byte file</td><td align="right">4.794.658</td></tr><tr><td>Write 16-byte file (atomic)</td><td align="right">4.995.794</td></tr><tr><td>Write 16MB file</td><td align="right">8.658.106</td></tr></table></p>
 <h4>Miscellaneous Tests</h4><p><table border="1"><tr><td>Name</td><td>Each (ns)</td></tr><tr><td>Zero-second delayed perform</td><td align="right">335</td></tr><tr><td>pthread create/join</td><td align="right">806.348</td></tr></table></p>

</td>
</tr>
</table>
</body>
